#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>

void recebeMsgs(int ns);

//Servidor TCP 
int main(int argc, char *argv[])
{
    unsigned short port;          
    struct sockaddr_in client, server; 
    int s;                     // Socket para aceitar conexões       
    int ns;                    // Socket conectado ao cliente        
    int namelen;          

    //Verifica se os parametros da aplicacao foram inseridos corretamente
    if (argc != 2)
    {
        printf("Use: %s porta\n", argv[0]);
        exit(1);
    }

    port = (unsigned short) atoi(argv[1]);

    //Cria um socket TCP (stream) para aguardar conexões     
    if ((s = socket(PF_INET, SOCK_STREAM, 0)) < 0)
    {
        perror("Socket()");
        exit(2);
    }

    // Define a qual endereço IP e porta o servidor estará ligado.
    // IP = INADDDR_ANY -> faz com que o servidor se ligue em todos os endereços IP    
    server.sin_family = AF_INET;   
    server.sin_port   = htons(port);       
    server.sin_addr.s_addr = INADDR_ANY;

    //Liga o servidor à porta definida anteriormente.     
    if (bind(s, (struct sockaddr *)&server, sizeof(server)) < 0)
    {
       perror("Bind()");
       exit(3);
    }

    
    //Prepara o socket para aguardar por conexões e cria uma fila de conexões pendentes.     
    if (listen(s, 1) != 0)
    {
        perror("Listen()");
        exit(4);
    }

    //Aceita uma conexão e cria um novo socket através do qual ocorrerá a comunicação com o cliente.     
    namelen = sizeof(client);
    if ((ns = accept(s, (struct sockaddr *)&client, &namelen)) == -1)
    {
        perror("Accept()");
        exit(5);
    }

	recebeMsgs(ns);

    // Fecha o socket conectado ao cliente 
    close(ns);

    // Fecha o socket aguardando por conexões 
    close(s);
        
    return 0;
}

void recebeMsgs(int ns)
{
	//Variaveis usadas para o armazenamento das mensagens e para respostas ao cliente
    int qtdRespostas = 0, count = 0, qtdApagadas = 0;         
    char comando[10], texto[50], usuario[10];
    char usuario1[10] = "";
    char usuario2[10] = "";
    char usuario3[10] = "";
    char usuario4[10] = "";
    char usuario5[10] = "";
    char texto1[50] = "";
    char texto2[50] = "";
    char texto3[50] = "";
    char texto4[50] = "";
    char texto5[50] = "";
    
    char confirm[5] = "";
	
    // Recebe uma mensagem do cliente através do novo socket conectado 
    if (recv(ns, &comando, sizeof(comando), 0) < 0)
    {
        perror("Recv(comando)");
        exit(6);
    }
    printf("\n**Comando recebido do cliente: %s\n", comando);
    
    //Recebe o usuario do cliente
    if (recv(ns, &usuario, sizeof(usuario), 0) < 0)
    {
        perror("Recv(usuario)");
        exit(7);
    }

    printf("Usuario: %s\n", usuario);

    //Recebe o texto do cliente
    if (recv(ns, &texto, sizeof(texto), 0) < 0)  //Verificar, nao esta recebendo por completo!
						   //09063125 = 3125, Vazio = o, 09041923 = 41923.. WHY?
    {
        perror("Recv(texto)");
        exit(8);
    }
    
    printf("Mensagem: %s\n\n", texto);

    
    //Verifica qual foi o comando enviado e executa sua funcao
    //se comando = "SalvaMsg", a opcao 1 foi selecionada. Sendo assim as informacoes recebidas devem ser salvas
    if(strcmp(comando, "SalvaMsg") == 0) 
    {		
		for(count = 1; count <= 5; count++)
		{
			switch(count)
			{
				case 1:
				{
					if(strcmp(usuario1, "") == 0)   //Mostra que o nome do primeiro usuario esta vazio, consequentemente tambem esta o texto
					{
						strcpy(usuario1, usuario);
						strcpy(texto1, texto);
						strcpy(confirm, "OK");
						count = 6;                  //Count = 6 faz com que o loop nao aconteca novamente para nao ahver duplicacao de mensagens
					}					
					break;
				}
				case 2:
				{
					if(strcmp(usuario2, "") == 0)
					{
						strcpy(usuario2, usuario);
						strcpy(texto2, texto);
						strcpy(confirm, "OK");
						count = 6;
					}					
					break;
				}
				case 3:
				{
					if(strcmp(usuario3, "") == 0)
					{
						strcpy(usuario3, usuario);
						strcpy(texto3, texto);
						strcpy(confirm, "OK");
						count = 6;
					}					
					break;
				}
				case 4:
				{
					if(strcmp(usuario4, "") == 0)
					{
						strcpy(usuario4, usuario);
						strcpy(texto4, texto);
						strcpy(confirm, "OK");
						count = 6;
					}					
					break;
				}
				case 5:
				{
					if(strcmp(usuario5, "") == 0)
					{
						strcpy(usuario5, usuario);
						strcpy(texto5, texto);
						strcpy(confirm, "OK");
						count = 6;
					}					
					break;
				}
			}
			
			if(strcmp(confirm, "OK") == 0)
			{
				qtdRespostas = 1;
			}
			else
				qtdRespostas = 0;
			
			if(send(ns, &qtdRespostas, sizeof(qtdRespostas), 0) < 0)
			{
				perror("Send(1 -> confirm)");
				exit(9);
			} 
			
			if(qtdRespostas == 1)
			{
				if(send(ns, confirm, strlen(confirm)+1, 0) < 0) //Envia a confirm de recebimento da mensagem para o cliente
				{
					perror("Send(confirm)");
					exit(9);
				}	
			}		
		}
	}
	// se comando = "ReturnMsg", a opcao 2 foi selecionada. Sendo assim todas as informacoes salvas devem ser retornadas
	else if(strcmp(comando, "ReturnMsg") == 0) 
	{
		for(count = 1; count <= 5; count++)   //conta quantas posicoes sao diferentes de ""
		{
			switch(count)
			{
				case 1:
				{
					if(strcmp(usuario1, "") != 0)
					{
						qtdRespostas++;
					}
					break;
				}
				case 2:
				{
					if(strcmp(usuario2, "") != 0)
					{
						qtdRespostas++;
					}
					break;
				}
				case 3:
				{
					if(strcmp(usuario3, "") != 0)
					{
						qtdRespostas++;
					}
					break;
				}
				case 4:
				{
					if(strcmp(usuario4, "") != 0)
					{
						qtdRespostas++;
					}
					break;
				}
				case 5:
				{
					if(strcmp(usuario5, "") != 0)
					{
						qtdRespostas++;
					}
					break;
				}
			}
		}

		if(send(ns, &qtdRespostas, sizeof(qtdRespostas), 0) < 0) // Envia qtdRespostas
		{
			perror("Send(qtdRespostas)");
			exit(10);
		}
		
		for(count = 1; count <= qtdRespostas; count++)
		{
			switch(count)
			{
				case 1:
				{
					if(strcmp(usuario1, "") != 0)   //Mostra que o nome do primeiro usuario esta vazio, consequentemente tambem esta o texto
					{
						strcpy(usuario, usuario1);
						strcpy(texto, texto1);
					}					
					break;
				}
				case 2:
				{
					if(strcmp(usuario2, "") != 0)
					{
						strcpy(usuario, usuario2);
						strcpy(texto, texto2);
					}					
					break;
				}
				case 3:
				{
					if(strcmp(usuario3, "") != 0)
					{
						strcpy(usuario, usuario3);
						strcpy(texto, texto3);
					}					
					break;
				}
				case 4:
				{
					if(strcmp(usuario4, "") != 0)
					{
						strcpy(usuario, usuario4);
						strcpy(texto, texto4);
					}					
					break;
				}
				case 5:
				{
					if(strcmp(usuario5, "") != 0)
					{
						strcpy(usuario, usuario5);
						strcpy(texto, texto5);
					}					
					break;
				}
			}
				
			if(send(ns, usuario, strlen(usuario)+1, 0) < 0)
			{
				perror("Send(usuarioRetorno)");
				exit(11);
			}
			if(send(ns, texto, strlen(texto)+1, 0) < 0)
			{
				perror("Send(textoRetorno)");
				exit(12);
			}				
		}
	}
	
	// se comando = "ApagaMsg", a opcao 3 foi selecionada. Sendo assim o servidor deve retornar todas as mensagens do usuario
    // fornecido para o cliente e em seguida apagar tais mensagens
	else if(strcmp(comando, "ApagaMsg") == 0) 
	{
		qtdApagadas = 0;
		
		for(count = 1; count <= 5; count++) //Calcula quantas mensagens serao apagadas
		{
			switch(count)
			{
				case 1:
				{
					if(strcmp(usuario, usuario1) == 0)
					{
						qtdApagadas++;
					}
				}
				case 2:
				{
					if(strcmp(usuario, usuario2) == 0)
					{
						qtdApagadas++;
					}
				}
				case 3:
				{
					if(strcmp(usuario, usuario3) == 0)
					{
						qtdApagadas++;
					}
				}
				case 4:
				{
					if(strcmp(usuario, usuario4) == 0)
					{
						qtdApagadas++;
					}
				}
				case 5:
				{
					if(strcmp(usuario, usuario5) == 0)
					{
						qtdApagadas++;
					}
				}
			}
		}
		
		if(send(ns, &qtdApagadas, sizeof(qtdApagadas), 0) < 0)
		{
			perror("Send(qtdApagadas)");
			exit(13);
		}
		
		for(count = 1; count <= 5; count++)
		{
			switch(count)
				{
					case 1:
					{
						if(strcmp(usuario1, usuario) == 0)  //Mostra que em tal posicao, o nome do usuario eh igual ao nome recebido para apagar
						{
							strcpy(usuario, usuario1);
							strcpy(texto, texto1);
							
							strcpy(usuario1, "");
							strcpy(texto1, "");   //Apaga o valore das variaves
						}					
						break;
					}
					case 2:
					{
						if(strcmp(usuario2, "") == 0)
						{
							strcpy(usuario, usuario2);
							strcpy(texto, texto2);
							
							strcpy(usuario2, "");
							strcpy(texto2, "");
						}					
						break;
					}
					case 3:
					{
						if(strcmp(usuario3, "") != 0)
						{
							strcpy(usuario, usuario3);
							strcpy(texto, texto3);
							
							strcpy(usuario3, "");
							strcpy(texto3, "");
						}					
						break;
					}
					case 4:
					{
						if(strcmp(usuario4, "") != 0)
						{
							strcpy(usuario, usuario4);
							strcpy(texto, texto4);
							
							strcpy(usuario4, "");
							strcpy(texto4, "");
						}					
						break;
					}
					case 5:
					{
						if(strcmp(usuario5, "") != 0)
						{
							strcpy(usuario, usuario5);
							strcpy(texto, texto5);
							
							strcpy(usuario5, "");
							strcpy(texto5, "");
						}					
						break;
					}
				}
				
				if(send(ns, usuario, strlen(usuario)+1, 0) < 0)
				{
					perror("Send(usuarioApaga)");
					exit(14);
				}
				if(send(ns, texto, strlen(texto)+1, 0) < 0)
				{
					perror("Send(textoApaga)");
					exit(15);
				}
		}
	}    
    
	recebeMsgs(ns);
    
}


